---
tags: dev, regex
---
## 패턴변경자(정규표현식 옵션)
정규표현식을 테스트해보거나 공부할 때 아래 두 페이지에서 많은 도움을 받았다. 

정규표현식 엔진별로 되는게 있고 안되는게 있기 때문에 일부 제한은 있겠지만 기본적인 것은 무리가 없다.

  

<Site Link>

- 정규표현식을 시각화 해주는 사이트 : [https://regexper.com/documentation.html](https://regexper.com/documentation.html)   

- 정규표현식을 연습할 수 있는 사이트 : [http://regexr.com/](http://regexr.com/)

  

텍스트에서 대소문자 상관없이 'THE'라는 단어를 검색한다고 하면, (the|The|THE) 처럼 글자들을 쭉 나열해야 할 것이다. 

그런데 패턴변경자라는 것을 사용하면 이를 쉽게 바꿀 수 있다. 주요 패턴변경자로는 아래와 같은 것들이 있다.

  

- i : 대소문자 구분없이 검색한다. [a-z]로 검색해도 [a-zA-Z]로 검색한 것 처럼 만든다.

- m : 텍스트를 다중 행으로 취급한다. ^$가 텍스트 전체의 끝이 아니라, 한 행의 끝으로 취급된다.

- s : 메타문자 '.'를 모든 문자에 매칭시킨다. 

- x : 공백문자를 찾지 않고 무시한다.

(이 외에도 여러가지가 있는데, 이정도가 자주 쓰일 것 같아서 나머지는 기재하지 않았다.)

  

검색하는 패턴 앞에 (?패턴변경자)로 써주거나, ex) (?i)the

패턴 구분자 뒤에 붙여서 사용한다. ex) /the/i

  

위에 기재한 패턴변경자는 Java, perl, PCRE에서 모두 지원하지만 정규표현식의 다른 부분들도 그러하듯, 

패턴변경자에 따라서는 언어나 엔진별로 되는게 있고 안되는게 있다.(사용법도 각각 가능여부가 다른 듯 하다.) 

예를 들어, Linux에서 grep으로 정규표현식을 사용할때는 보통 확장정규표현식을 쓰는 grep -E '패턴' 텍스트명.확장자 꼴로 쓰는데,

여기에서 대소문자 구분없이 쓰려면 grep -Ei xxxx 처럼 grep 자체에 i옵션을 주어야 한다.

단, grep -P 를 사용하면 PCRE 표현식을 사용할 수 있으므로 grep -P '(?i)the' test.txt 와 같이 쓸 수 있지만 

매뉴얼에도 적혀 있듯이, 아직까지는 실험적인 기능이다. 

  

 -P, --perl-regexp

Interpret the pattern as a  Perl-compatible  regular  expression(PCRE).

This  is  highly  experimental and grep -P may warn of unimplemented features.

  

StackOverFlow에도 grep -P 사용시 정규표현식은 맞는데 미스매치가 난다는 질문 글이 있다.

업그레이드 후 해결됐다는 글이 있는 걸로 보아, 아직은 사용할 단계가 아닌 듯.
## 비참조 그룹
정규표현식에서는 괄호( ex) **(Test)** )를 사용해서 그룹을 지정할 수 있다. 

나중에 사용하는 도구에 따라 **$1** 또는 **\1** 의 표현으로 괄호안의 표현식을 참조할 수 있는데, 

해당 내용을 메모리에 저장하기 때문에 성능에 영향을 줄 수 있다. 

만일 괄호 안의 내용을 나중에 참조할 필요가 없다면, 비참조 그룹을 활용하여 성능향상에 도움을 줄 수 있다.

그룹을 비참조 그룹으로 만들기 위해서는 왼쪽 괄호 다음에 '**?:**'를 적으면 된다.

예를 들어 **(the|THE)** 를 **(?:the|THE)**라고 적음으로써 비참조 그룹화시킬 수 있다.

만일 대소문자 구분 없이 모두 찾는 경우라면 옵션을 사용할 텐데, 그 때는 다음과 같이 쓰면 된다. 

**(?i)(?:the) = (?:(?i)the)=(?i:the)**

  

<참고>

(?>the)처럼 쓰는 것을 원자그룹이라고 하는데, 백트래킹을 사용하는 정규표현식 엔진에서 

원자그룹에 해당하는 부분은 백트래킹을 하지 않게 할 수 있다.
## 문자클래스
ㅁ 대괄호식(bracketed expressions)    ex) 단축문자 \d = 문자클래스 [0-9]

  - 10 ~ 19 사이의 짝수 표현 : \b[1][24680]\b

  - 0 ~ 99 사이의 짝수 표현 : \b[02468]\b | \b[1-9][02468]\b

  - 공백, 영문자, 숫자 등 : [\w\s] = [a-zA-Z0-9\t\n\r]

  

 o 부정문자클래스 

   - a, e, i, o, u를 제외 : [^aeiou]  <- 대괄호 안 시작위치에서 ^ 사용

 o 합집합, 차집합

   * Java 지원 (but 모든 정규표현식 엔진에서 지원하지는 않는다)

   - 0 ~ 3 또는 6 ~ 9 : [0-3[6-9]] 

   - a-z 문자중 m-r은 제외 : [a-z&&[^m-r]]

  

 o POSIX(Portable Operating System Interface) 문자클래스 (IEEE9 인터페이스 표준 규격)   

   - [[:xxxx:]] , [[:^xxxx:]] 형식으로 사용

   - 영문자숫자 : [[:alnum:]]

   - 아스키문자 : [[:ascii:]]

   - 공백문자 : [[:space:]]

   - 소문자 : [[:lower:]]

   - 숫자 : [[:digit:]]

   - 단어 : [[:word:]]

   - 문장부호 : [[:punct:]]

   - 알파벳문자 : [[:alpha:]]
## 수량자
<욕심쟁이 수량자> 

전체 문자열을 가져온 다음 제일 뒤 문자부터 시작하여 하나씩 백트래킹하며 일치하는지 검사한다. 때문에 시스템 자원 소비가 크다.

욕심쟁이 수량자는 **?, +, *, {n, m}** 와 같이 찾고자 하는 문자열 뒤에 사용한다.

예를 들어 원본 텍스트가 **99999** 인 경우, **9+**로 검색하면 뒤에서 부터 찾는 방향으로 탐색하기 때문에 **99999**가 선택된다.

  

<게으른 수량자>

문자열을 처음 위치부터 시작하여 일치하는 문자가 등장할 때 까지 하나씩 탐색해 나간다. 

게으른 수량자는 **??, +?, *?, {n, m}?** 와 같이 욕심쟁이 수량자 뒤에 **?**를 붙인다.

원본 텍스트 **99999**에서 **9+?**로 검색하면 앞에서 부터 찾는 방향으로 탐색하기 때문에 **9**가 선택된다.

  

이 외에 독점적 수량자가 있다. 욕심쟁이 수량자처럼 최대한 많이 찾지만 백트래킹이 없고 찾은 내용을 표시하지 않는 특징이 있다. 

수량자 뒤에 +를 붙여서 사용한다. 

아직은 업무에서 쓰일 만한 때가 없었기 때문에 생략...